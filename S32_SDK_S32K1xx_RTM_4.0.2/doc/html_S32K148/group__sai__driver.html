<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>S32 SDK: SAI Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top" style="height:auto; width:100%"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <img id="projectlogo" style="height:auto; width:100%" alt="Logo" src="s32sdk_logo_small.jpg"/>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__sai__driver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">SAI Driver<div class="ingroups"><a class="el" href="group__sai.html">Synchronous Audio Interface (SAI)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This module covers the functionality of the Synchronous Audio Interface (SAI) peripheral driver. </p>
<p>The SAI driver implements communication using the SAI module in the S32K148 processor. </p>
<h2>Integration guideline</h2>
<h3>Compilation units</h3>
<p>The following files need to be compiled in the project: </p><pre class="fragment"> ${S32SDK_PATH}\platform\drivers\src\sai\sai_driver.c</pre><h3>Include path</h3>
<p>The following paths need to be added to the include path of the toolchain: </p><pre class="fragment"> ${S32SDK_PATH}\platform\drivers\inc\
 ${S32SDK_PATH}\platform\drivers\src\sai\</pre><h3>Compile symbols</h3>
<p>No special symbols are required for this component</p>
<h3>Dependencies</h3>
<p><a class="el" href="group__clock__manager.html">Clock Manager</a> <a class="el" href="group__osif.html">OS Interface (OSIF)</a> <a class="el" href="group__interrupt__manager.html">Interrupt Manager (Interrupt)</a> <a class="el" href="group__edma.html">Enhanced Direct Memory Access (eDMA)</a></p>
<h2>Features</h2>
<ul>
<li>Transmitter with independent bit clock and frame sync, or sync with receiver</li>
<li>Receiver with independent bit clock and frame sync, or sync with transmitter</li>
<li>Maximum frame size of 16 words</li>
<li>Word size of between 8-bits and 32-bits</li>
<li>Word size configured separately for first word and remaining words in frame</li>
<li>Mux channels into one dataline, or mux data lines into one memory block</li>
</ul>
<h2>How to integrate SAI in your application</h2>
<p>In order to use the SAI driver it must be first initialized in either transmit or receive mode, using functions <a class="el" href="group__sai__driver.html#ga84ddc07134224cb1ef54de638cd8e660" title="Initialize the transmitter of driver. ">SAI_DRV_TxInit()</a> or <a class="el" href="group__sai__driver.html#ga2ae728826c3e75628256fbc0f5227164" title="Initialize the receiver of driver. ">SAI_DRV_RxInit()</a>. Once initialized, it cannot be initialized again for the same SAI module instance until it is de-initialized, using <a class="el" href="group__sai__driver.html#ga480cd6f93450999fccf9f26521112a32" title="De-initialize transmitter. ">SAI_DRV_TxDeinit()</a> or <a class="el" href="group__sai__driver.html#ga6d9dab743b25538666a54a2b6728adf3" title="De-initialize receiver. ">SAI_DRV_RxDeinit()</a>. Different SAI module instances can function independently of each other. </p>
<p>In each mode (transmit/receive) are available two types of transfers: blocking and non-blocking. The functions which initiate blocking transfers will configure the time out for transmission. If time expires SAI_DRV_SendBlocking/SAI_DRV_ReceiveBlocking will return error and the transmission will be aborted. </p>
<h2>Important Notes</h2>
<ul>
<li>If transmitter is initialized with SAI_SYNC_WITH_OTHER option, transmitter must be initialized first and receiver must use SAI_ASYNC mode</li>
<li>If receiver is initialized with SAI_SYNC_WITH_OTHER option, receiver must be initialized first and transmitter must use SAI_ASYNC mode</li>
<li>DMA module has to be initialized prior to usage in DMA mode; also, DMA channels need to be allocated by the application (the driver only takes care of configuring the DMA channels received in the configuration structure)</li>
<li>There is a difference in ChannelEnable field usage between interrupt and dma mode:<br />
 In interrupt mode, if mux line is enabled then user must turn on only one bit in ChannelEnable, which will be the data line to output data. Number of data buffers to be muxed is specified in ChannelCount field.<br />
 In DMA mode, if mux line is enabled then user must turn on number of bits equal to number of data buffers to be muxed. The data lines corresponding to these bits will output the same as each other.<br />
 Also in DMA mode, if a mux mode is selected, ChannelEnable must be turned on from bit 0, and immediately aboves (for example turning on bit 0 and bit 2 is not a correct configuration).</li>
<li>When multiple SAI channel is enabled, number of DMA channels must be equal number of SAI channels. And in DMA component:<br />
 Channel arbitration must be set to "Fixed priority".<br />
 The first DMA channel must have the lowest DMA channel number and request source must be set properly (for example SAI0_TX). Other DMA channels must have request field set to "No request". </li>
</ul>
<h2>Example code</h2>
<div class="fragment"><div class="line"><span class="comment">/* sai0 configuration structure */</span> </div>
<div class="line"><a class="code" href="structsai__user__config__t.html">sai_user_config_t</a> sai0_InitConfig0;</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Driver state structure */</span></div>
<div class="line"><a class="code" href="structsai__state__t.html">sai_state_t</a> SAI0TxState;</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Fill configuration structure with I2S settings */</span></div>
<div class="line"><a class="code" href="group__sai__driver.html#gac77e7692672887a58cf9d26e4cfcb996">SAI_DRV_GetDefaultConfig</a>(&amp;sai0_InitConfig0);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Provide two data buffer for left and right channel */</span></div>
<div class="line">uint16_t* sendData[2U] = {LeftData, RightData};</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Initialize transmitter for SAI0 */</span></div>
<div class="line"><a class="code" href="group__sai__driver.html#ga84ddc07134224cb1ef54de638cd8e660">SAI_DRV_TxInit</a>(0U, &amp;sai0_InitConfig0, &amp;SAI0TxState);</div>
<div class="line"></div>
<div class="line"><span class="comment">/* Send blocking, timeout is 10ms */</span></div>
<div class="line"><a class="code" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> ret = <a class="code" href="group__sai__driver.html#ga2760ffcf0d6e521f0cff026845289be9">SAI_DRV_SendBlocking</a>(0U, (uint8_t**) sendData, sendBufferSize, 10U);</div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsai__xfer__state__t.html">sai_xfer_state_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit or receive state.  <a href="structsai__xfer__state__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsai__state__t.html">sai_state_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for internal use. This structure is used by the driver for its internal logic. It must be provided by the application through the initialize functions, then it cannot be freed until the driver is de-initialized using Deinit functions. The application should make no assumptions about the content of this structure.  <a href="structsai__state__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsai__user__config__t.html">sai_user_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User config structure. <br />
 <b>Note</b>: entries in this structure are affected by <a class="el" href="_s32_k148__features_8h.html#a81206819a03df3c52ea40fa600f36e08" title="Channel mode tristate or output zero. ">FEATURE_SAI_HAS_CHMOD</a>, which is device dependent and controlled from feature header file of the used device.  <a href="structsai__user__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga962aaabed1dc0db708fbaddbd77c36d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga962aaabed1dc0db708fbaddbd77c36d2">SAI_CHANNEL_0</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:ga962aaabed1dc0db708fbaddbd77c36d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga649dd88eafaab7d5074d640afa8465b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga649dd88eafaab7d5074d640afa8465b0">SAI_CHANNEL_1</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:ga649dd88eafaab7d5074d640afa8465b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90128d968a5b363323955c942daef7f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga90128d968a5b363323955c942daef7f4">SAI_CHANNEL_2</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:ga90128d968a5b363323955c942daef7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga992fa1b25bb383055b776e11378c141a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga992fa1b25bb383055b776e11378c141a">SAI_CHANNEL_3</a>&#160;&#160;&#160;0x8</td></tr>
<tr class="separator:ga992fa1b25bb383055b776e11378c141a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac11712e3ca2eaac15c30cfb56913ac78"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#gac11712e3ca2eaac15c30cfb56913ac78">sai_transfer_callback_t</a>) (<a class="el" href="group__sai__driver.html#ga160121f07f95c82ad85679e3239c24f7">sai_report_type_t</a> event, void *userData)</td></tr>
<tr class="memdesc:gac11712e3ca2eaac15c30cfb56913ac78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sai callback function type for nonblock transfer, also called to report events (sai_report_type_t).  <a href="#gac11712e3ca2eaac15c30cfb56913ac78">More...</a><br /></td></tr>
<tr class="separator:gac11712e3ca2eaac15c30cfb56913ac78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga160121f07f95c82ad85679e3239c24f7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga160121f07f95c82ad85679e3239c24f7">sai_report_type_t</a> { <br />
&#160;&#160;<a class="el" href="group__sai__driver.html#gga160121f07f95c82ad85679e3239c24f7a067248423c38cde52e9950627b09df2b">SAI_RX_COMPLETE</a> = 0x00U, 
<a class="el" href="group__sai__driver.html#gga160121f07f95c82ad85679e3239c24f7a092349e0e8e77f8a354167bed7521929">SAI_TX_COMPLETE</a> = 0x01U, 
<a class="el" href="group__sai__driver.html#gga160121f07f95c82ad85679e3239c24f7a8887198384f65cc3bb22a68c37445f38">SAI_ERROR</a> = 0x03U, 
<a class="el" href="group__sai__driver.html#gga160121f07f95c82ad85679e3239c24f7a19921ab842ecc6ce4be4704b1750b03f">SAI_FRAME_START</a> = 0x05U, 
<br />
&#160;&#160;<a class="el" href="group__sai__driver.html#gga160121f07f95c82ad85679e3239c24f7af16a4ce4effb2d0d1f31500cd55fbc40">SAI_RUN_ERROR</a> = 0x06U, 
<a class="el" href="group__sai__driver.html#gga160121f07f95c82ad85679e3239c24f7a6d38aa0e2c400228f19413a4481fb03b">SAI_SYNC_ERROR</a> = 0x07U
<br />
 }<tr class="memdesc:ga160121f07f95c82ad85679e3239c24f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report to enable.  <a href="group__sai__driver.html#ga160121f07f95c82ad85679e3239c24f7">More...</a><br /></td></tr>
<tr class="separator:ga160121f07f95c82ad85679e3239c24f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga2b119e9a1e596ea7b70e00e8ccc7a44d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga2b119e9a1e596ea7b70e00e8ccc7a44d">sai_transfer_type_t</a> { <a class="el" href="group__sai__driver.html#gga2b119e9a1e596ea7b70e00e8ccc7a44daa3a44653480eae72f6aa3c3e7a9338b3">SAI_INTERRUPT</a> = 0U, 
<a class="el" href="group__sai__driver.html#gga2b119e9a1e596ea7b70e00e8ccc7a44dadd0389d6d2a2e927769fced59ae719bf">SAI_DMA</a>
 }<tr class="memdesc:ga2b119e9a1e596ea7b70e00e8ccc7a44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer type.  <a href="group__sai__driver.html#ga2b119e9a1e596ea7b70e00e8ccc7a44d">More...</a><br /></td></tr>
<tr class="separator:ga2b119e9a1e596ea7b70e00e8ccc7a44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga149a994866a6952dbea45c913246bcf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga149a994866a6952dbea45c913246bcf7">sai_mux_mode_t</a> { <a class="el" href="group__sai__driver.html#gga149a994866a6952dbea45c913246bcf7add5f8aacc0edb4d166628b0a75328008">SAI_MUX_DISABLED</a> = 0U, 
<a class="el" href="group__sai__driver.html#gga149a994866a6952dbea45c913246bcf7a9dc119620ae641a162bc05a0af86f1b9">SAI_MUX_LINE</a> = 1U, 
<a class="el" href="group__sai__driver.html#gga149a994866a6952dbea45c913246bcf7a79168cedf886ca7aaa777c1579078f27">SAI_MUX_MEM</a> = 2U
 }<tr class="memdesc:ga149a994866a6952dbea45c913246bcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data mux line or mux memory.  <a href="group__sai__driver.html#ga149a994866a6952dbea45c913246bcf7">More...</a><br /></td></tr>
<tr class="separator:ga149a994866a6952dbea45c913246bcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga88390dba856027f775cac9e6f6ecbc17"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga88390dba856027f775cac9e6f6ecbc17">sai_sync_mode_t</a> { <a class="el" href="group__sai__driver.html#gga88390dba856027f775cac9e6f6ecbc17a13291d36e7257bdbebb33e3a9c6c0286">SAI_ASYNC</a> = 0U, 
<a class="el" href="group__sai__driver.html#gga88390dba856027f775cac9e6f6ecbc17a768cbca37dec3a34fdb2618e700516fa">SAI_SYNC_WITH_OTHER</a> = 1U
 }<tr class="memdesc:ga88390dba856027f775cac9e6f6ecbc17"><td class="mdescLeft">&#160;</td><td class="mdescRight">SAI run in sync or async mode. <br />
 <b>Note</b>: entries in this enum are affected by ::FEATURE_SAI_SYNC_WITH_OTHER_INST, which is device dependent and controlled from feature header file of the used device.  <a href="group__sai__driver.html#ga88390dba856027f775cac9e6f6ecbc17">More...</a><br /></td></tr>
<tr class="separator:ga88390dba856027f775cac9e6f6ecbc17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga4a3bc6ec7eaf0bf920d6e4050e462afb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga4a3bc6ec7eaf0bf920d6e4050e462afb">sai_master_clk_source_t</a> { <a class="el" href="group__sai__driver.html#gga4a3bc6ec7eaf0bf920d6e4050e462afba11461623678a007132ce29dcd9859403">SAI_BUS_CLK</a> = 0U, 
<a class="el" href="group__sai__driver.html#gga4a3bc6ec7eaf0bf920d6e4050e462afba5bce01dc24412aa3f43694eab02431e0">SAI_EXTERNAL_CLK</a> = 1U, 
<a class="el" href="group__sai__driver.html#gga4a3bc6ec7eaf0bf920d6e4050e462afba02a44634201b45e927a2a5f085ab0838">SAI_SOSC_CLK</a> = 2U
 }<tr class="memdesc:ga4a3bc6ec7eaf0bf920d6e4050e462afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select master clock. <br />
 <b>Note</b>: entries in this enum are affected by <a class="el" href="_s32_k148__features_8h.html#a0269bceff73f4636d72c67ff3969b71d" title="Master clock from bus clock. ">FEATURE_SAI_MSEL_BUS_CLK</a>, <a class="el" href="_s32_k148__features_8h.html#abdca59a4073337a7c6cf0fae9b548edd" title="Master clock from MCLK pin. ">FEATURE_SAI_MSEL_MCLK_PIN</a>, ::FEATURE_SAI_MSEL_FCD, <a class="el" href="_s32_k148__features_8h.html#a2e8a461b5db42093d7eaca25039e725b" title="Master clock from sosc clock. ">FEATURE_SAI_MSEL_SOSC_CLK</a>, ::FEATURE_SAI_MSEL_OTHER_MCLK_PIN, which is device dependent and controlled from feature header file of the used device.  <a href="group__sai__driver.html#ga4a3bc6ec7eaf0bf920d6e4050e462afb">More...</a><br /></td></tr>
<tr class="separator:ga4a3bc6ec7eaf0bf920d6e4050e462afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga2c6bc8da7fea3b0160f60576f34b3935"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga2c6bc8da7fea3b0160f60576f34b3935">sai_mask_mode_t</a> { <a class="el" href="group__sai__driver.html#gga2c6bc8da7fea3b0160f60576f34b3935a45f8608ca0d002af6d431465bcca7da1">SAI_MASK_TRISTATE</a> = 0U, 
<a class="el" href="group__sai__driver.html#gga2c6bc8da7fea3b0160f60576f34b3935adfff269e50556683ffe672209050aed4">SAI_MASK_ZERO</a> = 1U
 }<tr class="memdesc:ga2c6bc8da7fea3b0160f60576f34b3935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data line state for masked word, or if data line is disabled. Implements : sai_mask_mode_t_Class.  <a href="group__sai__driver.html#ga2c6bc8da7fea3b0160f60576f34b3935">More...</a><br /></td></tr>
<tr class="separator:ga2c6bc8da7fea3b0160f60576f34b3935"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
SAI Driver</h2></td></tr>
<tr class="memitem:ga1f8d15b09ebae88359ff273affd13e83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga1f8d15b09ebae88359ff273affd13e83">SAI_DRV_SetMaster</a> (uint32_t instNum, bool tx)</td></tr>
<tr class="memdesc:ga1f8d15b09ebae88359ff273affd13e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable tx/rx and disable rx/tx to change to tx/rx transfer, only use this when driver is used in half duplex way.  <a href="#ga1f8d15b09ebae88359ff273affd13e83">More...</a><br /></td></tr>
<tr class="separator:ga1f8d15b09ebae88359ff273affd13e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ddc07134224cb1ef54de638cd8e660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga84ddc07134224cb1ef54de638cd8e660">SAI_DRV_TxInit</a> (uint32_t instNum, const <a class="el" href="structsai__user__config__t.html">sai_user_config_t</a> *saiUserConfig, <a class="el" href="structsai__state__t.html">sai_state_t</a> *StateAlloc)</td></tr>
<tr class="memdesc:ga84ddc07134224cb1ef54de638cd8e660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the transmitter of driver.  <a href="#ga84ddc07134224cb1ef54de638cd8e660">More...</a><br /></td></tr>
<tr class="separator:ga84ddc07134224cb1ef54de638cd8e660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae728826c3e75628256fbc0f5227164"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga2ae728826c3e75628256fbc0f5227164">SAI_DRV_RxInit</a> (uint32_t instNum, const <a class="el" href="structsai__user__config__t.html">sai_user_config_t</a> *saiUserConfig, <a class="el" href="structsai__state__t.html">sai_state_t</a> *StateAlloc)</td></tr>
<tr class="memdesc:ga2ae728826c3e75628256fbc0f5227164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the receiver of driver.  <a href="#ga2ae728826c3e75628256fbc0f5227164">More...</a><br /></td></tr>
<tr class="separator:ga2ae728826c3e75628256fbc0f5227164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga480cd6f93450999fccf9f26521112a32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga480cd6f93450999fccf9f26521112a32">SAI_DRV_TxDeinit</a> (uint32_t instNum)</td></tr>
<tr class="memdesc:ga480cd6f93450999fccf9f26521112a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize transmitter.  <a href="#ga480cd6f93450999fccf9f26521112a32">More...</a><br /></td></tr>
<tr class="separator:ga480cd6f93450999fccf9f26521112a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9dab743b25538666a54a2b6728adf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga6d9dab743b25538666a54a2b6728adf3">SAI_DRV_RxDeinit</a> (uint32_t instNum)</td></tr>
<tr class="memdesc:ga6d9dab743b25538666a54a2b6728adf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize receiver.  <a href="#ga6d9dab743b25538666a54a2b6728adf3">More...</a><br /></td></tr>
<tr class="separator:ga6d9dab743b25538666a54a2b6728adf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2b4377b672c7ec03fd0d3a79df8521"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga2d2b4377b672c7ec03fd0d3a79df8521">SAI_DRV_TxGetBitClockFreq</a> (uint32_t instNum)</td></tr>
<tr class="memdesc:ga2d2b4377b672c7ec03fd0d3a79df8521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true bit clock frequency of transmitter.  <a href="#ga2d2b4377b672c7ec03fd0d3a79df8521">More...</a><br /></td></tr>
<tr class="separator:ga2d2b4377b672c7ec03fd0d3a79df8521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga006dd7d901a2a7960892a190864e11d4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga006dd7d901a2a7960892a190864e11d4">SAI_DRV_RxGetBitClockFreq</a> (uint32_t instNum)</td></tr>
<tr class="memdesc:ga006dd7d901a2a7960892a190864e11d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true bit clock frequency of receiver.  <a href="#ga006dd7d901a2a7960892a190864e11d4">More...</a><br /></td></tr>
<tr class="separator:ga006dd7d901a2a7960892a190864e11d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6befd2b7053a74be02a659b70c8d5e62"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga6befd2b7053a74be02a659b70c8d5e62">SAI_DRV_TxGetBitClockDiv</a> (uint32_t instNum)</td></tr>
<tr class="memdesc:ga6befd2b7053a74be02a659b70c8d5e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true bit clock divisor of transmitter.  <a href="#ga6befd2b7053a74be02a659b70c8d5e62">More...</a><br /></td></tr>
<tr class="separator:ga6befd2b7053a74be02a659b70c8d5e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaea58b966f567b6ad8a040eac64168a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#gaaaea58b966f567b6ad8a040eac64168a">SAI_DRV_RxGetBitClockDiv</a> (uint32_t instNum)</td></tr>
<tr class="memdesc:gaaaea58b966f567b6ad8a040eac64168a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true bit clock divisor of receiver.  <a href="#gaaaea58b966f567b6ad8a040eac64168a">More...</a><br /></td></tr>
<tr class="separator:gaaaea58b966f567b6ad8a040eac64168a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84e079420a5fd078e4dff771c339f2a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga84e079420a5fd078e4dff771c339f2a9">SAI_DRV_TxSetNextMaskWords</a> (uint32_t instNum, uint16_t Words)</td></tr>
<tr class="memdesc:ga84e079420a5fd078e4dff771c339f2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set masked word index of subsequent frames for transmitter.  <a href="#ga84e079420a5fd078e4dff771c339f2a9">More...</a><br /></td></tr>
<tr class="separator:ga84e079420a5fd078e4dff771c339f2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5912c988b3f9bbf34af37418a691c6c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga5912c988b3f9bbf34af37418a691c6c4">SAI_DRV_RxSetNextMaskWords</a> (uint32_t instNum, uint16_t Words)</td></tr>
<tr class="memdesc:ga5912c988b3f9bbf34af37418a691c6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set masked word index of subsequent frames for receiver.  <a href="#ga5912c988b3f9bbf34af37418a691c6c4">More...</a><br /></td></tr>
<tr class="separator:ga5912c988b3f9bbf34af37418a691c6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2760ffcf0d6e521f0cff026845289be9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga2760ffcf0d6e521f0cff026845289be9">SAI_DRV_SendBlocking</a> (uint32_t instNum, const uint8_t *data[], uint32_t count, uint32_t timeout)</td></tr>
<tr class="memdesc:ga2760ffcf0d6e521f0cff026845289be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a block of data, return when transfer complete.  <a href="#ga2760ffcf0d6e521f0cff026845289be9">More...</a><br /></td></tr>
<tr class="separator:ga2760ffcf0d6e521f0cff026845289be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66d85198ef9c7f00c0789d140bd8edb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga66d85198ef9c7f00c0789d140bd8edb4">SAI_DRV_Send</a> (uint32_t instNum, const uint8_t *data[], uint32_t count)</td></tr>
<tr class="memdesc:ga66d85198ef9c7f00c0789d140bd8edb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a block of data, return immidiately.  <a href="#ga66d85198ef9c7f00c0789d140bd8edb4">More...</a><br /></td></tr>
<tr class="separator:ga66d85198ef9c7f00c0789d140bd8edb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga506244a3a36ff039141d2bf5eff41f6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga506244a3a36ff039141d2bf5eff41f6d">SAI_DRV_GetSendingStatus</a> (uint32_t instNum, uint32_t *countRemain)</td></tr>
<tr class="memdesc:ga506244a3a36ff039141d2bf5eff41f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get status of a non-blocking transfer.  <a href="#ga506244a3a36ff039141d2bf5eff41f6d">More...</a><br /></td></tr>
<tr class="separator:ga506244a3a36ff039141d2bf5eff41f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56dd7ddd81ecad6c85d8372e18416003"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga56dd7ddd81ecad6c85d8372e18416003">SAI_DRV_AbortSending</a> (uint32_t instNum)</td></tr>
<tr class="memdesc:ga56dd7ddd81ecad6c85d8372e18416003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort an ongoing transfer.  <a href="#ga56dd7ddd81ecad6c85d8372e18416003">More...</a><br /></td></tr>
<tr class="separator:ga56dd7ddd81ecad6c85d8372e18416003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75298d5456a7119a67a8bf989268eb98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga75298d5456a7119a67a8bf989268eb98">SAI_DRV_ReceiveBlocking</a> (uint32_t instNum, uint8_t *data[], uint32_t count, uint32_t timeout)</td></tr>
<tr class="memdesc:ga75298d5456a7119a67a8bf989268eb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a block of data, return when transfer complete.  <a href="#ga75298d5456a7119a67a8bf989268eb98">More...</a><br /></td></tr>
<tr class="separator:ga75298d5456a7119a67a8bf989268eb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc63f5b81aa9313703fbfffb3c26a7e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#gafc63f5b81aa9313703fbfffb3c26a7e0">SAI_DRV_Receive</a> (uint32_t instNum, uint8_t *data[], uint32_t count)</td></tr>
<tr class="memdesc:gafc63f5b81aa9313703fbfffb3c26a7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a block of data, return immidiately.  <a href="#gafc63f5b81aa9313703fbfffb3c26a7e0">More...</a><br /></td></tr>
<tr class="separator:gafc63f5b81aa9313703fbfffb3c26a7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02332182da593dd666bb3c0288ba741f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga02332182da593dd666bb3c0288ba741f">SAI_DRV_GetReceivingStatus</a> (uint32_t instNum, uint32_t *countRemain)</td></tr>
<tr class="memdesc:ga02332182da593dd666bb3c0288ba741f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get status of a non-blocking transfer.  <a href="#ga02332182da593dd666bb3c0288ba741f">More...</a><br /></td></tr>
<tr class="separator:ga02332182da593dd666bb3c0288ba741f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32280b443b501863d2f55c17345f3eee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#ga32280b443b501863d2f55c17345f3eee">SAI_DRV_AbortReceiving</a> (uint32_t instNum)</td></tr>
<tr class="memdesc:ga32280b443b501863d2f55c17345f3eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort an ongoing transfer.  <a href="#ga32280b443b501863d2f55c17345f3eee">More...</a><br /></td></tr>
<tr class="separator:ga32280b443b501863d2f55c17345f3eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac77e7692672887a58cf9d26e4cfcb996"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sai__driver.html#gac77e7692672887a58cf9d26e4cfcb996">SAI_DRV_GetDefaultConfig</a> (<a class="el" href="structsai__user__config__t.html">sai_user_config_t</a> *uc)</td></tr>
<tr class="memdesc:gac77e7692672887a58cf9d26e4cfcb996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default config structure for I2S standard. Init config structure for I2S interface: Interrupt mode, internal generated bit clock, 44.1 kHz sample rate, 16 bit word, 2 channel, data line 0,.  <a href="#gac77e7692672887a58cf9d26e4cfcb996">More...</a><br /></td></tr>
<tr class="separator:gac77e7692672887a58cf9d26e4cfcb996"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga962aaabed1dc0db708fbaddbd77c36d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAI_CHANNEL_0&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sai__driver_8h_source.html#l00042">42</a> of file <a class="el" href="sai__driver_8h_source.html">sai_driver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga649dd88eafaab7d5074d640afa8465b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAI_CHANNEL_1&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sai__driver_8h_source.html#l00043">43</a> of file <a class="el" href="sai__driver_8h_source.html">sai_driver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga90128d968a5b363323955c942daef7f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAI_CHANNEL_2&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sai__driver_8h_source.html#l00044">44</a> of file <a class="el" href="sai__driver_8h_source.html">sai_driver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga992fa1b25bb383055b776e11378c141a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAI_CHANNEL_3&#160;&#160;&#160;0x8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="sai__driver_8h_source.html#l00045">45</a> of file <a class="el" href="sai__driver_8h_source.html">sai_driver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gac11712e3ca2eaac15c30cfb56913ac78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* sai_transfer_callback_t) (<a class="el" href="group__sai__driver.html#ga160121f07f95c82ad85679e3239c24f7">sai_report_type_t</a> event, void *userData)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sai callback function type for nonblock transfer, also called to report events (sai_report_type_t). </p>

<p>Definition at line <a class="el" href="sai__driver_8h_source.html#l00075">75</a> of file <a class="el" href="sai__driver_8h_source.html">sai_driver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga2c6bc8da7fea3b0160f60576f34b3935"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__sai__driver.html#ga2c6bc8da7fea3b0160f60576f34b3935">sai_mask_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data line state for masked word, or if data line is disabled. Implements : sai_mask_mode_t_Class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga2c6bc8da7fea3b0160f60576f34b3935a45f8608ca0d002af6d431465bcca7da1"></a>SAI_MASK_TRISTATE&#160;</td><td class="fielddoc">
<p>Line is in high z state </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2c6bc8da7fea3b0160f60576f34b3935adfff269e50556683ffe672209050aed4"></a>SAI_MASK_ZERO&#160;</td><td class="fielddoc">
<p>Line is output zero </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="sai__driver_8h_source.html#l00189">189</a> of file <a class="el" href="sai__driver_8h_source.html">sai_driver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4a3bc6ec7eaf0bf920d6e4050e462afb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__sai__driver.html#ga4a3bc6ec7eaf0bf920d6e4050e462afb">sai_master_clk_source_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select master clock. <br />
 <b>Note</b>: entries in this enum are affected by <a class="el" href="_s32_k148__features_8h.html#a0269bceff73f4636d72c67ff3969b71d" title="Master clock from bus clock. ">FEATURE_SAI_MSEL_BUS_CLK</a>, <a class="el" href="_s32_k148__features_8h.html#abdca59a4073337a7c6cf0fae9b548edd" title="Master clock from MCLK pin. ">FEATURE_SAI_MSEL_MCLK_PIN</a>, ::FEATURE_SAI_MSEL_FCD, <a class="el" href="_s32_k148__features_8h.html#a2e8a461b5db42093d7eaca25039e725b" title="Master clock from sosc clock. ">FEATURE_SAI_MSEL_SOSC_CLK</a>, ::FEATURE_SAI_MSEL_OTHER_MCLK_PIN, which is device dependent and controlled from feature header file of the used device. </p>
<p>Implements : sai_master_clk_source_t_Class </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4a3bc6ec7eaf0bf920d6e4050e462afba11461623678a007132ce29dcd9859403"></a>SAI_BUS_CLK&#160;</td><td class="fielddoc">
<p>Master clock is module bus clock </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4a3bc6ec7eaf0bf920d6e4050e462afba5bce01dc24412aa3f43694eab02431e0"></a>SAI_EXTERNAL_CLK&#160;</td><td class="fielddoc">
<p>Master clock is from external </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4a3bc6ec7eaf0bf920d6e4050e462afba02a44634201b45e927a2a5f085ab0838"></a>SAI_SOSC_CLK&#160;</td><td class="fielddoc">
<p>Master clock is from external oscillator/crystal </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="sai__driver_8h_source.html#l00150">150</a> of file <a class="el" href="sai__driver_8h_source.html">sai_driver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga149a994866a6952dbea45c913246bcf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__sai__driver.html#ga149a994866a6952dbea45c913246bcf7">sai_mux_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data mux line or mux memory. </p>
<p>Implements : sai_mux_mode_t_Class </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga149a994866a6952dbea45c913246bcf7add5f8aacc0edb4d166628b0a75328008"></a>SAI_MUX_DISABLED&#160;</td><td class="fielddoc">
<p>Each data line is a channel, uses a seperate memory block </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga149a994866a6952dbea45c913246bcf7a9dc119620ae641a162bc05a0af86f1b9"></a>SAI_MUX_LINE&#160;</td><td class="fielddoc">
<p>Only one data line (data line 0 for DMA mode) is used. Words on data line is alternated between channels, each channel data is a seperate memory block </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga149a994866a6952dbea45c913246bcf7a79168cedf886ca7aaa777c1579078f27"></a>SAI_MUX_MEM&#160;</td><td class="fielddoc">
<p>Words in memory block is alternated between channels, each channel data is on a seperate data line. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="sai__driver_8h_source.html#l00091">91</a> of file <a class="el" href="sai__driver_8h_source.html">sai_driver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga160121f07f95c82ad85679e3239c24f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__sai__driver.html#ga160121f07f95c82ad85679e3239c24f7">sai_report_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report to enable. </p>
<p>Implements : sai_report_type_t_Class </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga160121f07f95c82ad85679e3239c24f7a067248423c38cde52e9950627b09df2b"></a>SAI_RX_COMPLETE&#160;</td><td class="fielddoc">
<p>Rx transfer complete, user can start another transfer </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga160121f07f95c82ad85679e3239c24f7a092349e0e8e77f8a354167bed7521929"></a>SAI_TX_COMPLETE&#160;</td><td class="fielddoc">
<p>Tx transfer complete, user can start another transfer </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga160121f07f95c82ad85679e3239c24f7a8887198384f65cc3bb22a68c37445f38"></a>SAI_ERROR&#160;</td><td class="fielddoc">
<p>DMA error while transfer </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga160121f07f95c82ad85679e3239c24f7a19921ab842ecc6ce4be4704b1750b03f"></a>SAI_FRAME_START&#160;</td><td class="fielddoc">
<p>Indicate a frame start </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga160121f07f95c82ad85679e3239c24f7af16a4ce4effb2d0d1f31500cd55fbc40"></a>SAI_RUN_ERROR&#160;</td><td class="fielddoc">
<p>Overrun/underrun error. This event is useful for tx when user want to know whether all data in tx fifo has been pushed out to line and tx deinit can be called, since tx complete event only indicates all data from buffer has been pushed to hardware fifo </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga160121f07f95c82ad85679e3239c24f7a6d38aa0e2c400228f19413a4481fb03b"></a>SAI_SYNC_ERROR&#160;</td><td class="fielddoc">
<p>Frame sync error </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="sai__driver_8h_source.html#l00061">61</a> of file <a class="el" href="sai__driver_8h_source.html">sai_driver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga88390dba856027f775cac9e6f6ecbc17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__sai__driver.html#ga88390dba856027f775cac9e6f6ecbc17">sai_sync_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SAI run in sync or async mode. <br />
 <b>Note</b>: entries in this enum are affected by ::FEATURE_SAI_SYNC_WITH_OTHER_INST, which is device dependent and controlled from feature header file of the used device. </p>
<p>Implements : sai_sync_mode_t_Class </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga88390dba856027f775cac9e6f6ecbc17a13291d36e7257bdbebb33e3a9c6c0286"></a>SAI_ASYNC&#160;</td><td class="fielddoc">
<p>Independent clock </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga88390dba856027f775cac9e6f6ecbc17a768cbca37dec3a34fdb2618e700516fa"></a>SAI_SYNC_WITH_OTHER&#160;</td><td class="fielddoc">
<p>Bit clock and frame sync signal is taken from transmitter/receiver </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="sai__driver_8h_source.html#l00129">129</a> of file <a class="el" href="sai__driver_8h_source.html">sai_driver.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2b119e9a1e596ea7b70e00e8ccc7a44d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__sai__driver.html#ga2b119e9a1e596ea7b70e00e8ccc7a44d">sai_transfer_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer type. </p>
<p>Implements : sai_transfer_type_t_Class </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga2b119e9a1e596ea7b70e00e8ccc7a44daa3a44653480eae72f6aa3c3e7a9338b3"></a>SAI_INTERRUPT&#160;</td><td class="fielddoc">
<p>Transfer type is interrupt </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2b119e9a1e596ea7b70e00e8ccc7a44dadd0389d6d2a2e927769fced59ae719bf"></a>SAI_DMA&#160;</td><td class="fielddoc">
<p>Transfer type is DMA </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="sai__driver_8h_source.html#l00081">81</a> of file <a class="el" href="sai__driver_8h_source.html">sai_driver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga32280b443b501863d2f55c17345f3eee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAI_DRV_AbortReceiving </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort an ongoing transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga56dd7ddd81ecad6c85d8372e18416003"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAI_DRV_AbortSending </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort an ongoing transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac77e7692672887a58cf9d26e4cfcb996"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAI_DRV_GetDefaultConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsai__user__config__t.html">sai_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>uc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get default config structure for I2S standard. Init config structure for I2S interface: Interrupt mode, internal generated bit clock, 44.1 kHz sample rate, 16 bit word, 2 channel, data line 0,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">uc</td><td>Pointer to config structure to fill in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga02332182da593dd666bb3c0288ba741f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SAI_DRV_GetReceivingStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>countRemain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get status of a non-blocking transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">countRemain</td><td>Number of words remain for each channel. This parameter can be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the transfer, can be success, aborted, timeout or busy. </dd></dl>

</div>
</div>
<a class="anchor" id="ga506244a3a36ff039141d2bf5eff41f6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SAI_DRV_GetSendingStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>countRemain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get status of a non-blocking transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">countRemain</td><td>Number of words remain for each channel. This parameter can be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the transfer, can be success, aborted, timeout or busy. Note that for tx, success status imply that all data has been pushed to hardware fifo and another transfer can be started. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc63f5b81aa9313703fbfffb3c26a7e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAI_DRV_Receive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a block of data, return immidiately. </p>
<p>When transfer completed, the callback function will be executed. User should use this callback function to immidiately start another transfer to avoid data overrun error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Array of pointer to each data block to transfer, each data block corresponds to an enabled channels If mux memory is selected, only first data block is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of words to transfer for each channel. In DMA mode, count number upper limit is limited by DMA BITER/CITER register length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75298d5456a7119a67a8bf989268eb98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SAI_DRV_ReceiveBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a block of data, return when transfer complete. </p>
<p>Should be called immidiately after a transfer complete to avoid data overrun error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Array of pointer to each data block to transfer, each data block corresponds to an enabled channels If mux memory is selected, only first data block is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of words to transfer for each channel. In DMA mode, count number upper limit is limited by DMA BITER/CITER register length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout to return when transfer take too long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success, error or timeout status. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d9dab743b25538666a54a2b6728adf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAI_DRV_RxDeinit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize receiver. </p>
<p>This function de-initializes driver. The driver can't be used again until reinitialized. The context structure is no longer needed by the driver and can be freed after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaaea58b966f567b6ad8a040eac64168a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SAI_DRV_RxGetBitClockDiv </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true bit clock divisor of receiver. </p>
<p>Only used when bit clock is internal and master clock is external </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Divisor factor </dd></dl>

</div>
</div>
<a class="anchor" id="ga006dd7d901a2a7960892a190864e11d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SAI_DRV_RxGetBitClockFreq </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true bit clock frequency of receiver. </p>
<p>Only used when master clock and bit clock is internal</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Frequency in hertz </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ae728826c3e75628256fbc0f5227164"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAI_DRV_RxInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsai__user__config__t.html">sai_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>saiUserConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsai__state__t.html">sai_state_t</a> *&#160;</td>
          <td class="paramname"><em>StateAlloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the receiver of driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saiUserConfig</td><td>Pointer to the user configuration structure. The function reads configuration data from this structure and initializes the driver accordingly. The application may free this structure after the function returns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">StateAlloc</td><td>Pointer to the state structure. The driver uses this memory area for its internal logic. The application must make no assumptions about the content of this structure, and must not free this memory until the driver is de-initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5912c988b3f9bbf34af37418a691c6c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAI_DRV_RxSetNextMaskWords </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Words</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set masked word index of subsequent frames for receiver. </p>
<p>Set masked words of subsequent frames. Each bit is a masked word. Should be called in frame start event callback or in four bit clock cycles after Rx init.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WordIndex</td><td>Word index to mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga66d85198ef9c7f00c0789d140bd8edb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAI_DRV_Send </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a block of data, return immidiately. </p>
<p>When transfer completed, the callback function will be executed. User should use this callback function to immidiately start an other transfer to avoid data underrun error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Array of pointer to each data block to transfer, each data block corresponds to an enabled channels If mux memory is selected, only first data block is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of words to transfer for each channel. In DMA mode, count number upper limit is limited by DMA BITER/CITER register length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2760ffcf0d6e521f0cff026845289be9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="status_8h.html#af9bff8ff1154a04a899276af806b8586">status_t</a> SAI_DRV_SendBlocking </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a block of data, return when transfer complete. </p>
<p>Should be called immediately after a transfer complete to avoid data underrun error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Array of pointer to each data block to transfer, each data block corresponds to an enabled channels If mux memory is selected, only first data block is used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of words to transfer for each channel. In DMA mode, count number upper limit is limited by DMA BITER/CITER register length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout to return when transfer take too long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success, error or timeout status. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f8d15b09ebae88359ff273affd13e83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAI_DRV_SetMaster </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable tx/rx and disable rx/tx to change to tx/rx transfer, only use this when driver is used in half duplex way. </p>
<p>In master mode, if user want to alternate between tx and rx operation (half duplex), both tx and rx need to be initialized as ASYNC, and this function must be called when:</p><ul>
<li>Before calling the first tx/rx transfer</li>
<li>After a tx/rx transfer end and before start another rx/tx transfer.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx</td><td>True if next operation is tx, false otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga480cd6f93450999fccf9f26521112a32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAI_DRV_TxDeinit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize transmitter. </p>
<p>This function de-initializes driver. The driver can't be used again until reinitialized. The context structure is no longer needed by the driver and can be freed after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6befd2b7053a74be02a659b70c8d5e62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SAI_DRV_TxGetBitClockDiv </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true bit clock divisor of transmitter. </p>
<p>Only used when bit clock is internal and master clock is external </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Frequency in hertz </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d2b4377b672c7ec03fd0d3a79df8521"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SAI_DRV_TxGetBitClockFreq </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true bit clock frequency of transmitter. </p>
<p>Only used when master clock and bit clock is internal</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84ddc07134224cb1ef54de638cd8e660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAI_DRV_TxInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsai__user__config__t.html">sai_user_config_t</a> *&#160;</td>
          <td class="paramname"><em>saiUserConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsai__state__t.html">sai_state_t</a> *&#160;</td>
          <td class="paramname"><em>StateAlloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the transmitter of driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">saiUserConfig</td><td>Pointer to the user configuration structure. The function reads configuration data from this structure and initializes the driver accordingly. The application may free this structure after the function returns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">StateAlloc</td><td>Pointer to the state structure. The driver uses this memory area for its internal logic. The application must make no assumptions about the content of this structure, and must not free this memory until the driver is de-initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84e079420a5fd078e4dff771c339f2a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SAI_DRV_TxSetNextMaskWords </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>instNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Words</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set masked word index of subsequent frames for transmitter. </p>
<p>Each bit is a masked word. Should be called in frame start event callback or in four bit clock cycles after Tx init.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instNum</td><td>Peripheral instance number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WordIndex</td><td>Word index to mask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Divisor factor </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jun 11 2021 08:16:21 for S32 SDK by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
